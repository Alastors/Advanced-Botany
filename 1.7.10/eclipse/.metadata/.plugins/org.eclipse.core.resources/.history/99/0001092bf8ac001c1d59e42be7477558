package ab.common.block.tile;

import java.util.List;

import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.ChatComponentTranslation;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import vazkii.botania.api.internal.VanillaPacketDispatcher;
import vazkii.botania.common.block.tile.TileMod;

public class TileGameBoard extends TileMod {
	
	public String[] playersName = new String[] { "", "" };
	public byte[] slotChance = new byte[] { 0, 0, 0, 0 };
	protected int botTick = -1;
	public int endGameTick = -1;
	protected boolean requestUpdate;
	public boolean isSingleGame = false;
	public int clientTick[] = new int[] { 0, 0, 0, 0 };

	public void updateEntity() {
		if(botTick > 0)
			botTick--;
		if(endGameTick > 0)
			endGameTick--;
		if(!worldObj.isRemote)
			updateServer();
	}
	
	public void updateAnimationTicks() {
		for(int i = 0; i < slotChance.length; i++)
			if(slotChance[i] > 0)
				clientTick[i]++;
			else
				clientTick[i] = 0;
	}
	
	protected void updateServer() {
		if(hasGame() && endGameTick == 0) 
			finishGame();
		if(requestUpdate)
			VanillaPacketDispatcher.dispatchTEToNearbyPlayers(this.worldObj, this.xCoord, this.yCoord, this.zCoord);
		boolean hasUpdate = false;
		if(isSingleGame && botTick == 0 && hasGame()) {
			for(int i = 2; i < 4; i++) {
				if(slotChance[i] == 0) {
					slotChance[i] = (byte)(worldObj.rand.nextInt(6) + 1);
					botTick = -1;
					hasUpdate = true;
					break;
				}
			}
		}
		requestUpdate = hasUpdate;
	}
	
	public void setPlayer(EntityPlayer player) {
		if(isSingleGame) {
			playersName[0] = player.getCommandSenderName();
			playersName[1] = "";
			requestUpdate = true;
			botTick = 8;
		} else {
			if(playersName[0].isEmpty()) 
				playersName[0] = player.getCommandSenderName();	
			else if(!playersName[0].equals(player.getCommandSenderName()))
				playersName[1] = player.getCommandSenderName();
			requestUpdate = true;
		}
	}
	
	public boolean dropDice(EntityPlayer player) {
		if(isSingleGame) {
			if(player.getCommandSenderName().equals(playersName[0]) && botTick == -1) {
				boolean isLastDice = false;
				for(int i = 0; i < 2; i++) {
					if(slotChance[i] == 0 && !worldObj.isRemote) {
						slotChance[i] = (byte)(worldObj.rand.nextInt(6) + 1);
						botTick = 18;
						requestUpdate = true;
						if(i == 1)
							isLastDice = true;
						break;
					}
				}
				if(isLastDice)
					endGameTick = 28;
				return true;
			}
		} else {
			for(int i = 0; i < playersName.length; i++) {
				if(player.getCommandSenderName().equals(playersName[i])) {
					for(int j = i * 2; j < (i + 1) * 2; j++) {
						if(slotChance[j] == 0 && !worldObj.isRemote) {
							slotChance[j] = (byte)(worldObj.rand.nextInt(6) + 1);
							requestUpdate = true;
							if(hasFullDice())
								endGameTick = 28;
							break;
						}
					}
					return true;
				}			
			}
		}
		return false;
	}
	
	public boolean hasFullDice() {
		boolean hasFull = false;
		for(int i = 0; i < slotChance.length; i++) {
			if(!(slotChance[i] > 0))
				return false;
			hasFull = slotChance[i] > 0;
		}
		return hasFull;
	}
	
	public boolean hasGame() {
		if(isSingleGame)
			return !playersName[0].isEmpty();
		else
			for(int i = 0; i < playersName.length; i++)
				if(!playersName[i].isEmpty())
					return true;
		return false;
	}
	
	public void finishGame() {
		if(worldObj.isRemote)
			return;
		if(isSingleGame) {
			if((slotChance[0] + slotChance[1]) > (slotChance[2] + slotChance[3]))
				sendNearMessage(playersName[0] + " you Won");
			else if((slotChance[0] + slotChance[1]) == (slotChance[2] + slotChance[3]))
				sendNearMessage(playersName[0] + " not win");
			else
				sendNearMessage(playersName[0] + " you Lose!");
			resetGame();
		} else {
			if((slotChance[0] + slotChance[1]) > (slotChance[2] + slotChance[3]))
				sendNearMessage(playersName[0] + " you Won!");
			else if((slotChance[0] + slotChance[1]) == (slotChance[2] + slotChance[3]))
				sendNearMessage(playersName[0] + " " + playersName[1] + "we are not win");
			else
				sendNearMessage(playersName[1] + " you Won!");
			resetGame();
		}
	}
	
	public void sendNearMessage(String text) {
		List<EntityPlayer> players = this.worldObj.getEntitiesWithinAABB(EntityPlayer.class, AxisAlignedBB.getBoundingBox(this.xCoord, this.yCoord, this.zCoord, (this.xCoord + 1), (this.yCoord + 1), (this.zCoord + 1)).expand(3.5f, 3.5f, 3.5f));		
		for(EntityPlayer player : players) {
			if(player != null)
				player.addChatMessage((new ChatComponentTranslation(text, new Object[] {})).setChatStyle((new ChatStyle()).setColor(EnumChatFormatting.DARK_GREEN)));
		}
	}
	
	public void resetGame() {
		playersName[0] = "";
		playersName[1] = "";
		for(int i = 0; i < slotChance.length; i++)
			slotChance[i] = 0;
		botTick = -1;
		endGameTick = -1;
		requestUpdate = true;
	}
	
	public void writeCustomNBT(NBTTagCompound cmp) {
		super.writeCustomNBT(cmp);
		for(int i = 0; i < playersName.length; i++)
			cmp.setString("playerName" + i, playersName[i]);
		cmp.setByteArray("slotChance", slotChance);
		cmp.setInteger("botTick", botTick);
		cmp.setInteger("endGameTick", endGameTick);
		cmp.setBoolean("requestUpdate", requestUpdate);
		cmp.setBoolean("isSingleGame", isSingleGame);
	}
	
	public void readCustomNBT(NBTTagCompound cmp) {
		super.readCustomNBT(cmp);
		for(int i = 0; i < playersName.length; i++)
			playersName[i] = cmp.getString("playerName" + i);
		botTick = cmp.getInteger("botTick");
		endGameTick = cmp.getInteger("endGameTick");
		slotChance = cmp.getByteArray("slotChance");
		requestUpdate = cmp.getBoolean("requestUpdate");
		isSingleGame = cmp.getBoolean("isSingleGame");
	}
}