package ab.common.block.tile;

import java.util.List;

import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.ChatComponentTranslation;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import vazkii.botania.api.internal.VanillaPacketDispatcher;

public class TileGameBoard extends TileInventory {
	
	protected String[] playersName = new String[] { "", "" };
	public byte[] slotChance = new byte[] { 0, 0, 0, 0 };
	protected int botTick = -1;
	public int endGameTick = -1;
	protected boolean requestUpdate;
	public boolean isSingleGame = true;
	public int clientTick[] = new int[] { 0, 0, 0, 0};

	public void updateEntity() {
		System.out.println(hasGame());
		if(botTick > 0)
			botTick--;
		if(endGameTick > 0)
			endGameTick--;
		if(!worldObj.isRemote)
			updateServer();
		else
			updateClient();
	}
	
	protected void updateClient() {
		for(int i = 0; i < slotChance.length; i++)
			if(slotChance[i] > 0)
				clientTick[i]++;
			else
				clientTick[i] = 0;
	}
	
	protected void updateServer() {
		if(requestUpdate)
			VanillaPacketDispatcher.dispatchTEToNearbyPlayers(this.worldObj, this.xCoord, this.yCoord, this.zCoord);
		boolean hasUpdate = false;
		if(isSingleGame && botTick == 0 && hasGame()) {
			for(int i = 2; i < 4; i++) {
				if(slotChance[i] == 0) {
					slotChance[i] = (byte)(worldObj.rand.nextInt(6) + 1);
					botTick = -1;
					hasUpdate = true;
					break;
				}
			}
		}
		if(hasGame() && endGameTick == 0) 
			finishGame();
		requestUpdate = hasUpdate;
	}
	
	public void setPlayer(EntityPlayer player) {
		if(isSingleGame) {
			playersName[0] = player.getCommandSenderName();
			playersName[1] = "";
			requestUpdate = true;
			botTick = 8;
		} 
	}
	
	public boolean dropDice(EntityPlayer player) {
		if(isSingleGame) {
			if(player.getCommandSenderName() == playersName[0] && botTick <= 0) {
				boolean isLastDice = false;
				for(int i = 0; i < 2; i++) {
					if(slotChance[i] == 0 && !worldObj.isRemote) {
						slotChance[i] = (byte)(worldObj.rand.nextInt(6) + 1);
						botTick = 18;
						requestUpdate = true;
						if(i == 1)
							isLastDice = true;
						break;
					}
				}
				if(isLastDice)
					endGameTick = 28;
				return true;
			}
		}
		return false;
	}
	
	public boolean hasGame() {
		if(isSingleGame)
			return !playersName[0].isEmpty();
		return !playersName[0].isEmpty() && !playersName[1].isEmpty();
	}
	
	public void finishGame() {
		if(worldObj.isRemote)
			return;
		if(isSingleGame) {
			if((slotChance[0] + slotChance[1]) > (slotChance[2] + slotChance[3]))
				sendNearMessage(playersName[0] + " you Won");
			else
				sendNearMessage(playersName[0] + " you Lose!");
			resetGame();
			requestUpdate = true;
		}
	}
	
	public void sendNearMessage(String text) {
		List<EntityPlayer> players = this.worldObj.getEntitiesWithinAABB(EntityPlayer.class, AxisAlignedBB.getBoundingBox(this.xCoord, this.yCoord, this.zCoord, (this.xCoord + 1), (this.yCoord + 1), (this.zCoord + 1)).expand(3.5f, 3.5f, 3.5f));		
		for(EntityPlayer player : players) {
			if(player != null)
				player.addChatMessage((new ChatComponentTranslation(text, new Object[] {})).setChatStyle((new ChatStyle()).setColor(EnumChatFormatting.DARK_GREEN)));
		}
	}
	
	public void resetGame() {
		playersName[0] = "";
		playersName[1] = "";
		for(int i = 0; i < slotChance.length; i++)
			slotChance[i] = 0;
		requestUpdate = true;
		botTick = -1;
		endGameTick = -1;
	}
	
	public void writeCustomNBT(NBTTagCompound cmp) {
		super.writeCustomNBT(cmp);
		for(int i = 0; i < playersName.length; i++)
			cmp.setString("playerName" + i, playersName[i]);
		cmp.setByteArray("slotChance", slotChance);
		cmp.setInteger("botTick", botTick);
		cmp.setInteger("endGameTick", endGameTick);
		cmp.setBoolean("requestUpdate", requestUpdate);
		cmp.setBoolean("isSingleGame", isSingleGame);
	}
	
	public void readCustomNBT(NBTTagCompound cmp) {
		super.readCustomNBT(cmp);
		for(int i = 0; i < playersName.length; i++)
			playersName[i] = cmp.getString("playerName" + i);
		botTick = cmp.getInteger("botTick");
		endGameTick = cmp.getInteger("endGameTick");
		slotChance = cmp.getByteArray("slotChance");
		requestUpdate = cmp.getBoolean("requestUpdate");
		isSingleGame = cmp.getBoolean("isSingleGame");
	}

	public int getInventoryStackLimit() {
		return 1;
	}
	
	public int getSizeInventory() {
		return 4;
	}

	public String getInventoryName() {
		return "inv.gameBoard";
	}
}